<!DOCTYPE HTML>
<html lang="en">
<head>
  <title>Flask-SocketIO Test</title>
  <script type="text/javascript" src="//code.jquery.com/jquery-1.9.1.min.js"></script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/9.1.3/css/bootstrap-slider.min.css">

  <script type="text/javascript"
          src="//cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/9.1.3/bootstrap-slider.min.js"></script>

  <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

  <style>
    #ex1Slider .slider-selection {
      background: #BABABA;
    }
    #harness {
      width: 255px;
      height: 255px;
      background-color: black;
    }
    #points-text {
      width: 255px;
      height: 255px;
    }
  </style>

  <script type="text/javascript" charset="utf-8">
    $(document).ready(function () {
      var blossom = window.blossom = {};

      // Use a "/test" namespace.
      // An application can open a connection on multiple namespaces, and
      // Socket.IO will multiplex all those connections on a single
      // physical channel. If you don't care about multiple channels, you
      // can set the namespace to an empty string.
      namespace = '/test';

      // Connect to the Socket.IO server.
      // The connection URL has the following format:
      //     http[s]://<domain>:<port>[/<namespace>]
      var socket = io.connect('http://' + document.domain + ':' + location.port + namespace);

      // Event handler for new connections.
      // The callback function is invoked when a connection with the
      // server is established.
      socket.on('connect', function () {
        socket.emit('my event', {data: 'I\'m connected!'});
      });

      // Event handler for server sent data.
      // The callback function is invoked whenever the server emits data
      // to the client. The data is then displayed in the "Received"
      // section of the page.
      socket.on('my response', function (msg) {
        $('#log').append('<br>' + $('<div/>').text('Received #' + msg.count + ': ' + msg.data).html());
      });

      // Interval function that tests message latency by sending a "ping"
      // message. The server then responds with a "pong" message and the
      // round trip time is measured.
      var ping_pong_times = [];
      var start_time;
      window.setInterval(function () {
        start_time = (new Date).getTime();
        socket.emit('my ping');
      }, 1000);

      // Handler for the "pong" message. When the pong is received, the
      // time from the ping is stored, and the average of the last 30
      // samples is average and displayed.
      socket.on('my pong', function () {
        var latency = (new Date).getTime() - start_time;
        ping_pong_times.push(latency);
        ping_pong_times = ping_pong_times.slice(-30); // keep last 30 samples
        var sum = 0;
        for (var i = 0; i < ping_pong_times.length; i++)
          sum += ping_pong_times[i];
        $('#ping-pong').text(Math.round(10 * sum / ping_pong_times.length) / 10);
      });

      var comms = window.comms = {};
      comms.sendPoints = function() {
        socket.emit('points', {data: grapher.points.splice(0, grapher.pointsPerFrame) });
      };

      socket.on('points received', function (msg) {
        $('#log').append('<br>' + $('<div/>').text('Received #' + msg.count + ': ' + msg.data).html());
      });


      var harness = blossom.harness = {};
      harness.init = function() {
        harness.$canvas = $('#harness');
        harness.$pointsText = $('#points-text');
        harness.canvas = harness.$canvas[0];
        harness.context = harness.canvas.getContext("2d");
      };

      harness.clear = function() {
        harness.context.clearRect(0, 0, harness.canvas.width, harness.canvas.height);
      };

      harness.init();

      var grapher = blossom.grapher = {};

      grapher.redMask = 1;
      grapher.greenMask = 2;
      grapher.blueMask = 4;

      grapher.init = function(harness) {
        grapher.context = harness.context;
        grapher.width = harness.$canvas.width();
        grapher.height = harness.$canvas.height();
        grapher.centerX = grapher.width / 2;
        grapher.centerY = grapher.height / 2;
        grapher.multX = grapher.centerX; // amount of space between center and boundary (sin/cos multiplier)
        grapher.multY = grapher.centerY;
        grapher.configFrame = [2]; // 2 byte representation of the tone
        grapher.points = [128]; // calculated points in frames
        grapher.pointsPerFrame = 0;
      };

      grapher.calcCycle = function( pointsPerFrame, circleSize, circleRatio, smallCirclePhase, redMin, redMax, greenMin, greenMax, blueMin, blueMax ) {
        grapher.pointsPerFrame = pointsPerFrame;
        var frameMult = 360 / pointsPerFrame;
        var bigCircleMultiplier = (circleRatio / 100);
        var sizeMultiplier = (circleSize / 100);


        var redMinCutoff = (redMin) / 100;
        var redMaxCutoff = (redMax) / 100;
        var greenMinCutoff = (greenMin) / 100;
        var greenMaxCutoff = (greenMax) / 100;
        var blueMinCutoff = (blueMin) / 100;
        var blueMaxCutoff = (blueMax) / 100;

        for (var i = 0; i < pointsPerFrame; i++) {
          var degrees = frameMult * i;
          var radians = degrees * (Math.PI / 180);

          var bigCircleX = Math.sin(radians) * bigCircleMultiplier;
          var bigCircleY = Math.cos(radians) * bigCircleMultiplier;
          var smallCircleXSin = Math.sin(radians * smallCirclePhase);
          var smallCircleYSin = Math.cos(radians * smallCirclePhase);
          var smallCircleX = smallCircleXSin * (1 - bigCircleMultiplier);
          var smallCircleY = smallCircleYSin * (1 - bigCircleMultiplier);

          var circleSumX = (bigCircleX + smallCircleX);
          var circleSumY = (bigCircleY + smallCircleY);

          var posX = circleSumX * grapher.multX * sizeMultiplier + grapher.centerX;
          var posY = circleSumY * grapher.multY * sizeMultiplier + grapher.centerY;

          var hypotenuse = Math.pow( Math.pow(circleSumX, 2) + Math.pow(circleSumY, 2), 0.5 );

          var color = '#';
          var red = ((hypotenuse >= redMinCutoff) && (hypotenuse <= redMaxCutoff)) ? grapher.redMask : 0;
          var green = ((hypotenuse >= greenMinCutoff) && (hypotenuse <= greenMaxCutoff)) ? grapher.greenMask : 0;
          var blue = ((hypotenuse >= blueMinCutoff) && (hypotenuse <= blueMaxCutoff)) ? grapher.blueMask : 0;

          grapher.points[i] = [Math.floor(posX), Math.floor(posY), red + green + blue];
        }
      };


      grapher.drawCycle = function() {
        var points = grapher.points;
        var pointsPerFrame = grapher.pointsPerFrame;
        var context = grapher.context;
        var fromX, fromY, lastX, lastY;
        var red, green, blue;

        for (var i = 0; i < pointsPerFrame; i++) {
          if (i === 0) {
            fromX = points[pointsPerFrame - 1][0];
            fromY = points[pointsPerFrame - 1][1];
          } else {
            fromX = points[i - 1][0];
            fromY = points[i - 1][1];
          }
          context.beginPath();
          context.moveTo(fromX, fromY);
          context.lineTo(points[i][0], points[i][1]);
          red = (grapher.redMask & points[i][2]) * 255;
          green = (grapher.greenMask & points[i][2]) * 255;
          blue = (grapher.blueMask & points[i][2]) * 255;
          context.strokeStyle = 'rgb(' + red + ','  + green + ','  + blue + ')';
          //context.strokeStyle = 'rgb(255, 0 , 0)';
          context.stroke();
        }
      };


      grapher.clear = function() {
        grapher.context.clearRect(0, 0, grapher.width, grapher.height );
      };

      grapher.writePoints = function() {
        var text = '';
        for (var i = 0; i < grapher.pointsPerFrame; i++) {
          text += '[' + grapher.points[i][0] + ',' + grapher.points[i][1] + ',' + grapher.points[i][2] + ']';
        }
        harness.$pointsText.text( text );
      };

      grapher.init(harness);

      function drawCircle() {
        //frames, circleSize, circleRatio, smallCirclePhase, redPhase, greenPhase, bluePhase
        grapher.clear();
        grapher.calcCycle(
            sliders['points-per-frame'].value,
            sliders['circle-size'].value,
            sliders['circle-ratio'].value,
            sliders['circle-size-small'].value,
            sliders['phase-red'].value,
            sliders['phase-red'].value2,
            sliders['phase-green'].value,
            sliders['phase-green'].value2,
            sliders['phase-blue'].value,
          sliders['phase-blue'].value2
        );
        grapher.drawCycle();
        grapher.writePoints();
        comms.sendPoints();
      }

      var changeSlider = function (slider) {
        var newVal = slider.$el.val().split(',');

        slider.$val.text(newVal);
        slider.value = newVal[0];
        slider.value2 = newVal[1];
        drawCircle();
      };

      var sliders = blossom.sliders = {};

      $('input.slider').each(function () {
        var $slider = $(this);
        var $val = $slider.closest('.row').find('.slider-val');
        var sliderOptions = {
          $el: $slider,
          $val: $val,
          value: -1,
          value2: -1
        };
        sliders[$slider.attr('id')] = sliderOptions;
        $slider.slider({
          tooltip: 'hide'
        }).on('slide', function(event) { changeSlider(sliderOptions) });
      });

      $('input.slider').each(function () {
        $(this).trigger('slide');
      });


    });
  </script>
</head>
<body>

<div class="container">
  <h1>Blossom</h1>

  <p>Async mode is: <b>{{ async_mode }}</b></p>

  <p>Average ping/pong latency: <b><span id="ping-pong"></span>ms</b></p>

  <h2>Settings</h2>

  <div class="row">
    <div class="col-sm-4">
      Tone
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>
    </div>
    <div class="col-sm-7">
      <input class="slider" id="tone" data-event="tone" type="text" data-slider-min="0" data-slider-max="255"
             data-slider-step="1"
             data-slider-value="50"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-4">
      Points in frame
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>
    </div>
    <div class="col-sm-7">
      <input class="slider" id="points-per-frame" data-event="points per frame" type="text" data-slider-min="2" data-slider-max="128"
             data-slider-step="1"
             data-slider-value="128"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-4">
      Circle Size
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>

    </div>
    <div class="col-sm-7">
      <input class="slider" id="circle-size" data-event="circle size" type="text" data-slider-min="0"
             data-slider-max="100" data-slider-step="1"
             data-slider-value="100"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-4">
      Circle Ratio
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>

    </div>
    <div class="col-sm-7">
      <input class="slider" id="circle-ratio" data-event="circle ratio" type="text" data-slider-min="0"
             data-slider-max="100"
             data-slider-step="1" data-slider-value="50"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-4">
      Small circle phase
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>

    </div>
    <div class="col-sm-7">
      <input class="slider" id="circle-size-small" data-event="circle size small" type="text"
             data-slider-min="1" data-slider-max="10"
             data-slider-step="1" data-slider-value="6"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-4">
      Red Phase
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>

    </div>
    <div class="col-sm-7">
      <input class="slider" id="phase-red" data-event="phase red" type="text" data-slider-min="0"
             data-slider-max="100"
             data-slider-step="1" data-slider-value="[66, 100]"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-4">
      Green Phase
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>

    </div>
    <div class="col-sm-7">
      <input class="slider" id="phase-green" data-event="phase red" type="text" data-slider-min="0"
             data-slider-max="100"
             data-slider-step="1" data-slider-value="[33,66]"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-4">
      Blue Phase
    </div>
    <div class="col-sm-1">
      <span class="slider-val"></span>

    </div>
    <div class="col-sm-7">
      <input class="slider" id="phase-blue" data-event="phase blue" type="text" data-slider-min="0"
             data-slider-max="100"
             data-slider-step="1" data-slider-value="[0,33]"/>
    </div>
  </div>

  <div class="row">
    <div class="col-sm-6">
      <canvas id="harness" width= "255" height="255">

      </canvas>
    </div>
    <div class="col-sm-6">
      <textarea id="points-text">

      </textarea>
    </div>
  </div>

</div>


<div id="log"></div>
</body>
</html>
